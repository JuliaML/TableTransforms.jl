var documenterSearchIndex = {"docs":
[{"location":"devguide/#Developer-guide","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"A short guide for extending the interface as a developer.","category":"page"},{"location":"devguide/#Motivation","page":"Developer guide","title":"Motivation","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"TableTransforms.jl currently supports over 25 different transforms that cover a wide variety of use cases ranging from ordinary table operations to complex statistical transformations, which can be arbitrarily composed with one another through elegant syntax. It is easy to leverage all this functionality as a developer of new transforms, and this is the motivation of this guide.","category":"page"},{"location":"devguide/#Basic-assumptions","page":"Developer guide","title":"Basic assumptions","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"All the transforms in this package implement the transforms interface defined in the  TransformsBase.jl package so this is really the only dependency needed. The interface assumes the following about new transforms:","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"Transforms operate on a single table\nTransforms may be associated with some state that if computed while applying it for the first time and is then cached can help later reapply the transform on another table without recomputing the state\nThe transform may be revertible, meaning that a transformed table can be brought back to its original form, and it may need to use the cache for that\nYour transform may be invertible in the mathematical sense","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"note: Revertible does not imply invertible\nReversibility assumes that the transform has been applied already and can be undone. On the other hand, invertibility implies that there is a one-to-one mapping between the input and output tables so a table can be inverted to a corresponding input even if it was not transformed a priori.","category":"page"},{"location":"devguide/#Defining-a-new-transform","page":"Developer guide","title":"Defining a new transform","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"In the following we shall demonstrate the steps to define a new transform.","category":"page"},{"location":"devguide/#.-Declare-a-new-type-for-your-transform","page":"Developer guide","title":"1. Declare a new type for your transform","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"The type should subtype TransformsBase.Transform and it should have a named field for each  parameter needed to apply the transform besides the input table. For instance, if you want to call  your transform Standardize and it takes two boolean inputs center and scale , then you should declare:","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"struct Standardize <: TransformsBase.Transform\n  center::Bool\n  scale::Bool\nend","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"You may implement keyword constructors as needed if some of the parameters are optional:","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"Standardize(; center::Bool=true, scale::Bool=true) = Standardize(center, scale)","category":"page"},{"location":"devguide/#.-Implement-the-apply-method-for-your-transform","page":"Developer guide","title":"2. Implement the apply method for your transform","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"The apply method takes an instance of your transform type and a table and returns a new table  and cache. Suppose that the Standardize transform should zero-mean each column if center is  true and scale each column to unit variance if scale is true, then the apply method should  be implemented as follows:","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"using Statistics\n\nfunction TransformsBase.apply(transform::Standardize, X)\n    # convert the table to a matrix\n    Xm = Tables.matrix(X)\n    # compute the means and stds\n    μ = transform.center ? mean(Xm, dims=1) : zeros(1, size(Xm, 2))\n    σ = transform.scale ? std(Xm, dims=1) : ones(1, size(Xm, 2))\n    # standardize the data\n    Xm = (Xm .- μ) ./ σ\n    # convert back to table\n    Xm = X |> Tables.materializer(Xm)\n    # return the table and cache that may help reapply or revert later\n    return Xm, (μ, σ)\nend","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"That's it really! Your transform now behaves like any table transform:","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"using TableTransforms\n\nX = (A=[1, 2, 3], B=[4, 5, 6])\nXt = X |> Standardize() |> Identity() |> Select([:A])","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"It holds, however, that in case your transform can be reapplied, is revertible, or is  invertible then you should continue implementing the interface to support such functionality.","category":"page"},{"location":"devguide/#.-Optionally-implement-reapply","page":"Developer guide","title":"3. Optionally implement reapply","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"We need this in case of the Standarize transform because after computing the mean and std for  some training table we may want to apply the transform directly given a test table. Hence, we implement reapply which has the same signature as apply but it takes an extra argument for the cache and doesn't return it.","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"function TransformsBase.reapply(transform::Standardize, X, cache)\n    # convert the table to a matrix\n    Xm = Tables.matrix(X)\n    # no need to recompute means and stds\n    μ, σ = cache\n    # standardize the data\n    Xm = (Xm .- μ) ./ σ\n    # convert back to table\n    Xm = X |> Tables.materializer(Xm)\n    return Xm\nend","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"If not implemented, reapply simply falls back to apply.","category":"page"},{"location":"devguide/#.-Optionally-specify-that-your-transform-is-revertible-and-implement-revert","page":"Developer guide","title":"4. Optionally specify that your transform is revertible and implement revert","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"We can specify reversibility for an arbitrary transform T by setting isrevertible(::Type{T}) to true. It's obvious that this should be supported by our transform  so we do","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"TransformsBase.isrevertible(::Type{Standardize}) = true","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"By default this falls back to false so users of the interface would be aware that revert is not  implemented in that case. Now we follow up by implementing the revert method:","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"function TransformsBase.revert(transform::Standardize, X, cache)\n    # convert the table to a matrix\n    Xm = Tables.matrix(X)\n    # extract the mean and std\n    μ, σ = cache\n    # revert the transform\n    Xm = Xm .* σ .+ μ\n    # convert back to table\n    Xm = X |> Tables.materializer(Xm)\n    return Xm\nend","category":"page"},{"location":"devguide/#.-Optionally-specify-that-your-transform-is-invertible-and-implement-Base.inv","page":"Developer guide","title":"5. Optionally specify that your transform is invertible and implement Base.inv","text":"","category":"section"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"Similar to reversibility, falls back to false by default. We can write that explicitly here  since Standardize has no inverse if we are given nothing except for the table.","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"TransformsBase.isinvertible(::Type{Standardize}) = false","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"If an arbitrary transform T is invertible we can rather specify that as true and follow up by  implementing Base.inv(::T) which would be expected to return an instance of the inverse  transform. For instance, for an identity transform we can do","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"# interface struct\nstruct Identity <: Transform end\n# specify that it is invertible\nTransformsBase.isinvertible(::Type{Identity}) = true\n# implement Base.inv\nBase.inv(::Identity) = Identity()","category":"page"},{"location":"devguide/","page":"Developer guide","title":"Developer guide","text":"which implies that inv(Identity()) would return an identity transform.","category":"page"},{"location":"transforms/#Transforms","page":"Transforms","title":"Transforms","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Below is the list of transforms that are are available in this package.","category":"page"},{"location":"transforms/#Select","page":"Transforms","title":"Select","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Select","category":"page"},{"location":"transforms/#TableTransforms.Select","page":"Transforms","title":"TableTransforms.Select","text":"Select(col₁, col₂, ..., colₙ)\nSelect([col₁, col₂, ..., colₙ])\nSelect((col₁, col₂, ..., colₙ))\n\nThe transform that selects columns col₁, col₂, ..., colₙ.\n\nSelect(col₁ => newcol₁, col₂ => newcol₂, ..., colₙ => newcolₙ)\n\nSelects the columns col₁, col₂, ..., colₙ and rename them to newcol₁, newcol₂, ..., newcolₙ.\n\nSelect(regex)\n\nSelects the columns that match with regex.\n\nExamples\n\nSelect(1, 3, 5)\nSelect([:a, :c, :e])\nSelect((\"a\", \"c\", \"e\"))\nSelect(1 => :x, 3 => :y)\nSelect(:a => :x, :b => :y)\nSelect(\"a\" => \"x\", \"b\" => \"y\")\nSelect(r\"[ace]\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Reject","page":"Transforms","title":"Reject","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Reject","category":"page"},{"location":"transforms/#TableTransforms.Reject","page":"Transforms","title":"TableTransforms.Reject","text":"Reject(col₁, col₂, ..., colₙ)\nReject([col₁, col₂, ..., colₙ])\nReject((col₁, col₂, ..., colₙ))\n\nThe transform that discards columns col₁, col₂, ..., colₙ.\n\nReject(regex)\n\nDiscards the columns that match with regex.\n\nExamples\n\nReject(:b, :d, :f)\nReject([\"b\", \"d\", \"f\"])\nReject((2, 4, 6))\nReject(r\"[bdf]\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Rename","page":"Transforms","title":"Rename","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Rename","category":"page"},{"location":"transforms/#TableTransforms.Rename","page":"Transforms","title":"TableTransforms.Rename","text":"Rename(:col₁ => :newcol₁, :col₂ => :newcol₂, ..., :colₙ => :newcolₙ)\n\nThe transform that renames col₁, col₂, ..., colₙ to newcol₁, newcol₂, ..., newcolₙ.\n\nExamples\n\nRename(1 => :x, 3 => :y)\nRename(:a => :x, :c => :y)\nRename(\"a\" => \"x\", \"c\" => \"y\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/#StdNames","page":"Transforms","title":"StdNames","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"StdNames","category":"page"},{"location":"transforms/#TableTransforms.StdNames","page":"Transforms","title":"TableTransforms.StdNames","text":"StdNames(spec)\n\nStandardizes column names according to given spec. Default to :upper case specification.\n\nSpecs\n\n:upper - Uppercase, e.g. COLUMNNAME\n:camel - Camelcase, e.g. ColumnName\n:snake - Snakecase, e.g. column_name\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Sort","page":"Transforms","title":"Sort","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Sort","category":"page"},{"location":"transforms/#TableTransforms.Sort","page":"Transforms","title":"TableTransforms.Sort","text":"Sort(col₁, col₂, ..., colₙ; kwargs...)\nSort([col₁, col₂, ..., colₙ]; kwargs...)\nSort((col₁, col₂, ..., colₙ); kwargs...)\n\nSort the rows of selected columns col₁, col₂, ..., colₙ by forwarding the kwargs to the sortperm function.\n\nSort(regex; kwargs...)\n\nSort the rows of columns that match with regex.\n\nExamples\n\nSort(:a)\nSort(:a, :c, rev=true)\nSort([1, 3, 5], by=row -> abs.(row))\nSort((\"a\", \"c\", \"e\"))\nSort(r\"[ace]\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Sample","page":"Transforms","title":"Sample","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Sample","category":"page"},{"location":"transforms/#TableTransforms.Sample","page":"Transforms","title":"TableTransforms.Sample","text":"Sample(size, [weights]; replace=true, ordered=false, rng=GLOBAL_RNG)\n\nSample size rows of table using weights with or without replacement depending on the option replace. The option ordered can be used to return samples in the same order of the original table.\n\nExamples\n\nSample(1_000)\nSample(1_000, replace=false)\nSample(1_000, replace=false, ordered=true)\n\n# with rng\nusing Random\nrng = MersenneTwister(2)\nSample(1_000, rng=rng)\n\n# with weights\nSample(10, rand(100))\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Filter","page":"Transforms","title":"Filter","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Filter","category":"page"},{"location":"transforms/#TableTransforms.Filter","page":"Transforms","title":"TableTransforms.Filter","text":"Filter(func)\n\nFilters the table returning only the rows where the func returns true.\n\nExamples\n\nFilter(row -> sum(row) > 10)\nFilter(row -> row.a == true && row.b < 30)\nFilter(row -> row.\"a\" == true && row.\"b\" < 30)\nFilter(row -> row[1] == true && row[2] < 30)\nFilter(row -> row[:a] == true && row[:b] < 30)\nFilter(row -> row[\"a\"] == true && row[\"b\"] < 30)\n\nNotes\n\nThe schema of the table is preserved by the transform.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#DropMissing","page":"Transforms","title":"DropMissing","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"DropMissing","category":"page"},{"location":"transforms/#TableTransforms.DropMissing","page":"Transforms","title":"TableTransforms.DropMissing","text":"DropMissing()\nDropMissing(:)\n\nDrop all rows with missing values in table.\n\nDropMissing(col₁, col₂, ..., colₙ)\nDropMissing([col₁, col₂, ..., colₙ])\nDropMissing((col₁, col₂, ..., colₙ))\n\nDrop all rows with missing values in selected columns col₁, col₂, ..., colₙ.\n\nDropMissing(regex)\n\nDrop all rows with missing values in columns that match with regex.\n\nExamples\n\nDropMissing()\nDropMissing(\"b\", \"c\", \"e\")\nDropMissing([2, 3, 5])\nDropMissing((:b, :c, :e))\nDropMissing(r\"[bce]\")\n\nNotes\n\nThe transform can alter the element type of columns from Union{Missing,T} to T.\nIf the transformed column has only missing values, it will be converted to an empty column of type Any.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Replace","page":"Transforms","title":"Replace","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Replace","category":"page"},{"location":"transforms/#TableTransforms.Replace","page":"Transforms","title":"TableTransforms.Replace","text":"Replace(old₁ => new₁, old₂ => new₂, ..., oldₙ => newₙ)\n\nReplaces oldᵢ value with newᵢ value in the table.\n\nExamples\n\nReplace(1 => -1, 5 => -5)\nReplace(1 => 1.5, 5 => 5.5, 4 => true)\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Coalesce","page":"Transforms","title":"Coalesce","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Coalesce","category":"page"},{"location":"transforms/#TableTransforms.Coalesce","page":"Transforms","title":"TableTransforms.Coalesce","text":"Coalesce(; value)\n\nReplaces all missing values from the table with value.\n\nCoalesce(col₁, col₂, ..., colₙ; value)\nCoalesce([col₁, col₂, ..., colₙ]; value)\nCoalesce((col₁, col₂, ..., colₙ); value)\n\nReplaces all missing values from the columns col₁, col₂, ..., colₙ with value.\n\nCoalesce(regex; value)\n\nReplaces all missing values from the columns that match with regex with value.\n\nExamples\n\nCoalesce(value=0)\nCoalesce(1, 3, 5, value=1)\nCoalesce([:a, :c, :e], value=2)\nCoalesce((\"a\", \"c\", \"e\"), value=3)\nCoalesce(r\"[ace]\", value=4)\n\nNotes\n\nThe transform can alter the element type of columns from Union{Missing,T} to T.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Coerce","page":"Transforms","title":"Coerce","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Coerce","category":"page"},{"location":"transforms/#TableTransforms.Coerce","page":"Transforms","title":"TableTransforms.Coerce","text":"Coerce(pairs, tight=false, verbosity=1)\n\nReturn a copy of the table, ensuring that the scientific types of the columns match the new specification.\n\nThis transform wraps the ScientificTypes.coerce function. Please see their docstring for more details.\n\nExamples\n\nusing ScientificTypes\nCoerce(:col1 => Continuous, :col2 => Count)\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Levels","page":"Transforms","title":"Levels","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Levels","category":"page"},{"location":"transforms/#TableTransforms.Levels","page":"Transforms","title":"TableTransforms.Levels","text":"Levels(col₁ => levels₁, col₂ => levels₂, ..., colₙ => levelsₙ; ordered=nothing)\n\nConvert columns col₁, col₂, ..., colₙ to categorical arrays with given levels levels₁, levels₂, ..., levelsₙ. Optionally, specify which columns are ordered.\n\nExamples\n\nLevels(1 => 1:3, 2 => [\"a\", \"b\"], ordered=r\"a\")\nLevels(:a => 1:3, :b => [\"a\", \"b\"], ordered=[:a])\nLevels(\"a\" => 1:3, \"b\" => [\"a\", \"b\"], ordered=[\"b\"])\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Indicator","page":"Transforms","title":"Indicator","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Indicator","category":"page"},{"location":"transforms/#TableTransforms.Indicator","page":"Transforms","title":"TableTransforms.Indicator","text":"Indicator(col; k=10, scale=:quantile, categ=false)\n\nTransforms continuous variable into k indicator variables defined by half-intervals of col values in a given scale. Optionally, specify the categ option to return binary categorical values as opposed to raw 1s and 0s.\n\nGiven a sequence of increasing threshold values t1 < t2 < ... < tk, the indicator transform converts a continuous variable Z into a sequence of k variables Z_1 = Z <= t1, Z_2 = Z <= t2, ..., Z_k = Z <= tk.\n\nScales:\n\n:quantile - threshold values are calculated using the quantile(Z, p) function with a linear range of probabilities.\n:linear - threshold values are calculated using a linear range.\n\nExamples\n\nIndicator(1, k=3)\nIndicator(:a, k=6, scale=:linear)\nIndicator(\"a\", k=9, scale=:linear, categ=true)\n\n\n\n\n\n","category":"type"},{"location":"transforms/#OneHot","page":"Transforms","title":"OneHot","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"OneHot","category":"page"},{"location":"transforms/#TableTransforms.OneHot","page":"Transforms","title":"TableTransforms.OneHot","text":"OneHot(col; categ=false)\n\nTransforms categorical column col into one-hot columns of levels returned by the levels function of CategoricalArrays.jl. The categ option can be used to convert resulting columns to categorical arrays as opposed to boolean vectors.\n\nExamples\n\nOneHot(1)\nOneHot(:a)\nOneHot(\"a\")\nOneHot(\"a\", categ=true)\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Identity","page":"Transforms","title":"Identity","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Identity","category":"page"},{"location":"transforms/#TransformsBase.Identity","page":"Transforms","title":"TransformsBase.Identity","text":"Identity()\n\nThe identity transform that maps any object to itself.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Center","page":"Transforms","title":"Center","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Center","category":"page"},{"location":"transforms/#TableTransforms.Center","page":"Transforms","title":"TableTransforms.Center","text":"Center()\n\nApplies the center transform to all columns of the table. The center transform of the column x, with mean μ, is defined by x .- μ.\n\nCenter(col₁, col₂, ..., colₙ)\nCenter([col₁, col₂, ..., colₙ])\nCenter((col₁, col₂, ..., colₙ))\n\nApplies the Center transform on columns col₁, col₂, ..., colₙ.\n\nCenter(regex)\n\nApplies the Center transform on columns that match with regex.\n\nExamples\n\nCenter(1, 3, 5)\nCenter([:a, :c, :e])\nCenter((\"a\", \"c\", \"e\"))\nCenter(r\"[ace]\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Scale","page":"Transforms","title":"Scale","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Scale","category":"page"},{"location":"transforms/#TableTransforms.Scale","page":"Transforms","title":"TableTransforms.Scale","text":"Scale(; low=0.25, high=0.75)\n\nApplies the Scale transform to all columns of the table. The scale transform of the column x is defined by (x .- xl) ./ (xh - xl), where xl = quantile(x, low) and xh = quantile(x, high).\n\nScale(col₁, col₂, ..., colₙ; low=0.25, high=0.75)\nScale([col₁, col₂, ..., colₙ]; low=0.25, high=0.75)\nScale((col₁, col₂, ..., colₙ); low=0.25, high=0.75)\n\nApplies the Scale transform on columns col₁, col₂, ..., colₙ.\n\nScale(regex; low=0.25, high=0.75)\n\nApplies the Scale transform on columns that match with regex.\n\nExamples\n\nScale()\nScale(low=0, high=1)\nScale(low=0.3, high=0.7)\nScale(1, 3, 5, low=0, high=1)\nScale([:a, :c, :e], low=0.3, high=0.7)\nScale((\"a\", \"c\", \"e\"), low=0.25, high=0.75)\nScale(r\"[ace]\", low=0.3, high=0.7)\n\nNotes\n\nThe low and high values are restricted to the interval [0, 1].\n\n\n\n\n\n","category":"type"},{"location":"transforms/#MinMax","page":"Transforms","title":"MinMax","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"MinMax","category":"page"},{"location":"transforms/#TableTransforms.MinMax","page":"Transforms","title":"TableTransforms.MinMax","text":"MinMax()\n\nApplies the MinMax transform to all columns of the table. The MinMax transform is equivalent to Scale(low=0, high=1).\n\nMinMax(col₁, col₂, ..., colₙ)\nMinMax([col₁, col₂, ..., colₙ])\nMinMax((col₁, col₂, ..., colₙ))\n\nApplies the MinMax transform on columns col₁, col₂, ..., colₙ.\n\nMinMax(regex)\n\nApplies the MinMax transform on columns that match with regex.\n\nExamples\n\nMinMax(1, 3, 5)\nMinMax([:a, :c, :e])\nMinMax((\"a\", \"c\", \"e\"))\nMinMax(r\"[ace]\")\n\nSee also Scale.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Interquartile","page":"Transforms","title":"Interquartile","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Interquartile","category":"page"},{"location":"transforms/#TableTransforms.Interquartile","page":"Transforms","title":"TableTransforms.Interquartile","text":"Interquartile()\n\nApplies the Interquartile transform to all columns of the table. The Interquartile transform is equivalent to Scale(low=0.25, high=0.75).\n\nInterquartile(col₁, col₂, ..., colₙ)\nInterquartile([col₁, col₂, ..., colₙ])\nInterquartile((col₁, col₂, ..., colₙ))\n\nApplies the Interquartile transform on columns col₁, col₂, ..., colₙ.\n\nInterquartile(regex)\n\nApplies the Interquartile transform on columns that match with regex.\n\nExamples\n\nInterquartile(1, 3, 5)\nInterquartile([:a, :c, :e])\nInterquartile((\"a\", \"c\", \"e\"))\nInterquartile(r\"[ace]\")\n\nSee also Scale.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#ZScore","page":"Transforms","title":"ZScore","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"ZScore","category":"page"},{"location":"transforms/#TableTransforms.ZScore","page":"Transforms","title":"TableTransforms.ZScore","text":"ZScore()\n\nApplies the z-score transform (a.k.a. normal score) to all columns of the table. The z-score transform of the column x, with mean μ and standard deviation σ, is defined by (x .- μ) ./ σ.\n\nZScore(col₁, col₂, ..., colₙ)\nZScore([col₁, col₂, ..., colₙ])\nZScore((col₁, col₂, ..., colₙ))\n\nApplies the ZScore transform on columns col₁, col₂, ..., colₙ.\n\nZScore(regex)\n\nApplies the ZScore transform on columns that match with regex.\n\nExamples\n\nZScore(1, 3, 5)\nZScore([:a, :c, :e])\nZScore((\"a\", \"c\", \"e\"))\nZScore(r\"[ace]\")\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Quantile","page":"Transforms","title":"Quantile","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Quantile","category":"page"},{"location":"transforms/#TableTransforms.Quantile","page":"Transforms","title":"TableTransforms.Quantile","text":"Quantile(; dist=Normal())\n\nThe quantile transform to a given distribution.\n\nQuantile(col₁, col₂, ..., colₙ; dist=Normal())\nQuantile([col₁, col₂, ..., colₙ]; dist=Normal())\nQuantile((col₁, col₂, ..., colₙ); dist=Normal())\n\nApplies the Quantile transform on columns col₁, col₂, ..., colₙ.\n\nQuantile(regex; dist=Normal())\n\nApplies the Quantile transform on columns that match with regex.\n\nExamples\n\nusing Distributions\n\nQuantile()\nQuantile(dist=Normal())\nQuantile(1, 3, 5, dist=Beta())\nQuantile([:a, :c, :e], dist=Gamma())\nQuantile((\"a\", \"c\", \"e\"), dist=Beta())\nQuantile(r\"[ace]\", dist=Normal())\n\n\n\n\n\n","category":"type"},{"location":"transforms/#Functional","page":"Transforms","title":"Functional","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"Functional","category":"page"},{"location":"transforms/#TableTransforms.Functional","page":"Transforms","title":"TableTransforms.Functional","text":"Functional(func)\n\nThe transform that applies a func elementwise.\n\nFunctional(col₁ => func₁, col₂ => func₂, ..., colₙ => funcₙ)\n\nApply the corresponding funcᵢ function to each colᵢ column.\n\nExamples\n\nFunctional(cos)\nFunctional(sin)\nFunctional(1 => cos, 2 => sin)\nFunctional(:a => cos, :b => sin)\nFunctional(\"a\" => cos, \"b\" => sin)\n\n\n\n\n\n","category":"type"},{"location":"transforms/#EigenAnalysis","page":"Transforms","title":"EigenAnalysis","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"EigenAnalysis","category":"page"},{"location":"transforms/#TableTransforms.EigenAnalysis","page":"Transforms","title":"TableTransforms.EigenAnalysis","text":"EigenAnalysis(proj; maxdim=nothing, pratio=1.0)\n\nThe eigenanalysis of the covariance with a given projection proj. Optionally specify the maximum number of dimensions in the output maxdim and the percentage of variance to retain pratio. Default to all dimensions of the input.\n\nProjections\n\n:V - Uncorrelated variables (PCA transform)\n:VD - Uncorrelated variables and variance one (DRS transform)\n:VDV - Uncorrelated variables and variance one (SDS transformation)\n\nThe :V projection used in the PCA transform projects the data on the eigenvectors V of the covariance matrix.\n\nThe :VD projection used in the DRS transform. Similar to the :V projection, but the eigenvectors are multiplied by the squared inverse of the eigenvalues D.\n\nThe :VDV projection used in the SDS transform. Similar to the :VD transform, but the data is projected back to the basis of the original variables using the Vᵀ matrix.\n\nSee https://geostatisticslessons.com/lessons/sphereingmaf for more details about these three variants of eigenanalysis.\n\nExamples\n\nEigenAnalysis(:V)\nEigenAnalysis(:VD)\nEigenAnalysis(:VDV)\nEigenAnalysis(:V, maxdim=3)\nEigenAnalysis(:VD, pratio=0.99)\nEigenAnalysis(:VDV, maxdim=3, pratio=0.99)\n\n\n\n\n\n","category":"type"},{"location":"transforms/#PCA","page":"Transforms","title":"PCA","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"PCA","category":"page"},{"location":"transforms/#TableTransforms.PCA","page":"Transforms","title":"TableTransforms.PCA","text":"PCA(; maxdim=nothing, pratio=1.0)\n\nThe PCA transform is a shortcut for ZScore() → EigenAnalysis(:V; maxdim, pratio).\n\nSee also: ZScore, EigenAnalysis.\n\nExamples\n\nPCA(maxdim=2)\nPCA(pratio=0.86)\nPCA(maxdim=2, pratio=0.86)\n\n\n\n\n\n","category":"function"},{"location":"transforms/#DRS","page":"Transforms","title":"DRS","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"DRS","category":"page"},{"location":"transforms/#TableTransforms.DRS","page":"Transforms","title":"TableTransforms.DRS","text":"DRS(; maxdim=nothing, pratio=1.0)\n\nThe DRS transform is a shortcut for ZScore() → EigenAnalysis(:VD; maxdim, pratio).\n\nSee also: ZScore, EigenAnalysis.\n\nExamples\n\nDRS(maxdim=3)\nDRS(pratio=0.87)\nDRS(maxdim=3, pratio=0.87)\n\n\n\n\n\n","category":"function"},{"location":"transforms/#SDS","page":"Transforms","title":"SDS","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"SDS","category":"page"},{"location":"transforms/#TableTransforms.SDS","page":"Transforms","title":"TableTransforms.SDS","text":"SDS(; maxdim=nothing, pratio=1.0)\n\nThe SDS transform is a shortcut for ZScore() → EigenAnalysis(:VDV; maxdim, pratio).\n\nSee also: ZScore, EigenAnalysis.\n\nExamples\n\nSDS()\nSDS(maxdim=4)\nSDS(pratio=0.88)\nSDS(maxdim=4, pratio=0.88)\n\n\n\n\n\n","category":"function"},{"location":"transforms/#ProjectionPursuit","page":"Transforms","title":"ProjectionPursuit","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"ProjectionPursuit","category":"page"},{"location":"transforms/#TableTransforms.ProjectionPursuit","page":"Transforms","title":"TableTransforms.ProjectionPursuit","text":"ProjectionPursuit(; tol=1e-6, maxiter=100, deg=5, perc=0.9, n=100, rng=Random.GLOBAL_RNG)\n\nThe projection pursuit multivariate transform converts any multivariate distribution into the standard multivariate Gaussian distribution.\n\nThis iterative algorithm repeatedly finds a direction of projection α that maximizes a score of non-Gaussianity known as the projection index I(α). The samples projected along α are then transformed with the Quantile transform to remove the non-Gaussian structure. The other coordinates in the rotated orthonormal basis Q = [α ...] are left untouched.\n\nThe non-singularity of Q is controlled by assuring that norm(det(Q)) ≥ tol. The iterative  process terminates whenever the transformed samples are \"more Gaussian\" than perc% of n randomly generated samples from the standard multivariate Gaussian distribution, or when the  number of iterations reaches a maximum maxiter.\n\nExamples\n\nProjectionPursuit()\nProjectionPursuit(deg=10)\nProjectionPursuit(perc=0.85, n=50)\nProjectionPursuit(tol=1e-4, maxiter=250, deg=5, perc=0.95, n=100)\n\n# with rng\nusing Random\nrng = MersenneTwister(2)\nProjectionPursuit(perc=0.85, n=50, rng=rng)\n\nSee https://doi.org/10.2307/2289161 for  further details.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#RowTable","page":"Transforms","title":"RowTable","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"RowTable","category":"page"},{"location":"transforms/#TableTransforms.RowTable","page":"Transforms","title":"TableTransforms.RowTable","text":"RowTable()\n\nThe transform that applies the function Tables.rowtable to to the input table.\n\n\n\n\n\n","category":"type"},{"location":"transforms/#ColTable","page":"Transforms","title":"ColTable","text":"","category":"section"},{"location":"transforms/","page":"Transforms","title":"Transforms","text":"ColTable","category":"page"},{"location":"transforms/#TableTransforms.ColTable","page":"Transforms","title":"TableTransforms.ColTable","text":"ColTable()\n\nThe transform that applies the function Tables.columntable to to the input table.\n\n\n\n\n\n","category":"type"},{"location":"related/#Related","page":"Related","title":"Related","text":"","category":"section"},{"location":"related/","page":"Related","title":"Related","text":"FeatureTransforms.jl has transforms, but they are not fully revertible. Some of their transforms such as MeanStdScaling are constructed for a specific table and cannot be inserted in the middle of a pipeline for example.\nAutoMLPipeline.jl relies on the Python stack via PyCall.jl. They provide pipelines with Julia's pipe |> operator and follow a more \"Pythonic\" interface. They do not support general Tables.jl.\nImpute.jl, Cleaner.jl, DataConvenience.jl all have a small set of transforms related to fixing column names as well as other basic transforms that we plan to absorb in the long term.\nDataFramesMeta.jl is a package to manipulate DataFrames.jl tables. It is not intended for statistical transforms such as PCA, Quantile, etc, which rely on complex interactions between the rows and columns of a table. The usage of macros in the package promotes one-shot scripts as opposed to general pipelines that can be passed around to different places in the program.\nQuery.jl is a package to query IterableTables.jl. Similar to other alternatives above, the package is not intended for advanced statistical transforms.\nMLJ.jl is one of the most popular packages for machine learning in Julia. The package provides a facility for readily creating non-branching pipelines which can include supervised learners, as well as the flexibility to create more complicated composite machine learning models using so-called learning networks. These composites have the advantage that the hyper-parameters of the component models appear as nested fields of the composite, which is useful in hyper-parameter optimization.","category":"page"},{"location":"#TableTransforms.jl","page":"Home","title":"TableTransforms.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transforms and pipelines with tabular data.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides transforms that are commonly used in statistics and machine learning. It was developed to address specific needs in feature engineering and works with general Tables.jl tables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Past attempts to model transforms in Julia such as FeatureTransforms.jl served as inspiration for this package. We are happy to absorb any missing transform, and contributions are very welcome.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transforms are revertible meaning that one can apply a transform and undo the transformation without having to do all the manual work keeping constants around.\nPipelines can be easily constructed with clean syntax (f1 → f2 → f3) ⊔ (f4 → f5), and they are automatically revertible when the individual transforms are revertible.\nBranches of a pipeline and colwise transforms are run in parallel using multiple threads with the awesome Transducers.jl framework.\nPipelines can be reapplied to unseen \"test\" data using the same cache (e.g. constants) fitted with \"training\" data. For example, a ZScore relies on \"fitting\" μ and σ once at training time.","category":"page"},{"location":"#Rationale","page":"Home","title":"Rationale","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A common task in statistics and machine learning consists of transforming the variables of a problem to achieve better convergence or to apply methods that rely on multivariate Gaussian distributions. This process can be quite tedious to implement by hand and very error-prone. We provide a consistent and clean API to combine statistical transforms into pipelines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although most transforms discussed here come from the statistical domain, our long term vision is more ambitious. We aim to provide a complete user experience with fully-featured pipelines that include standardization of column names, imputation of missing data, and more.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the following table and its corner plot:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TableTransforms\nusing Plots, PairPlots\nusing Random; Random.seed!(2) # hide\ngr(format=:png) # hide\n\n# example table from PairPlots.jl\nN = 100_000\na = [2randn(N÷2) .+ 6; randn(N÷2)]\nb = [3randn(N÷2); 2randn(N÷2)]\nc = randn(N)\nd = c .+ 0.6randn(N)\ntable = (; a, b, c, d)\n\n# corner plot of original table\ntable |> corner","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can convert the columns to PCA scores:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# convert to PCA scores\ntable |> PCA() |> corner","category":"page"},{"location":"","page":"Home","title":"Home","text":"or to any marginal distribution:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Distributions\n\n# convert to any Distributions.jl\ntable |> Quantile(dist=Normal()) |> corner","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below is a more sophisticated example with a pipeline that has two parallel branches. The tables produced by these two branches are concatenated horizontally in the final table:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# create a transform pipeline\nf1 = ZScore()\nf2 = Scale()\nf3 = Quantile()\nf4 = Functional(cos)\nf5 = Interquartile()\npipeline = (f1 → f2 → f3) ⊔ (f4 → f5)\n\n# feed data into the pipeline\ntable |> pipeline |> corner","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each branch is a sequence of transforms constructed with the → (\\to<tab>) operator. The branches are placed in parallel with the ⊔ (\\sqcup<tab>) operator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"→\n⊔","category":"page"},{"location":"#TransformsBase.:→","page":"Home","title":"TransformsBase.:→","text":"transform₁ → transform₂ → ⋯ → transformₙ\n\nCreate a SequentialTransform transform with [transform₁, transform₂, …, transformₙ].\n\n\n\n\n\n","category":"function"},{"location":"#TableTransforms.:⊔","page":"Home","title":"TableTransforms.:⊔","text":"transform₁ ⊔ transform₂ ⊔ ⋯ ⊔ transformₙ\n\nCreate a ParallelTableTransform transform with [transform₁, transform₂, …, transformₙ].\n\n\n\n\n\n","category":"function"},{"location":"#Reverting-transforms","page":"Home","title":"Reverting transforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To revert a pipeline or single transform, use the apply and revert functions instead. The function isrevertible can be used to check if a transform is revertible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"apply\nrevert\nisrevertible","category":"page"},{"location":"#TransformsBase.apply","page":"Home","title":"TransformsBase.apply","text":"newobject, cache = apply(transform, object)\n\nApply transform on the object. Return the newobject and a cache to revert the transform later.\n\n\n\n\n\n","category":"function"},{"location":"#TransformsBase.revert","page":"Home","title":"TransformsBase.revert","text":"object = revert(transform, newobject, cache)\n\nRevert the transform on the newobject using the cache from the corresponding apply call and return the original object. Only defined when the transform isrevertible.\n\n\n\n\n\n","category":"function"},{"location":"#TransformsBase.isrevertible","page":"Home","title":"TransformsBase.isrevertible","text":"isrevertible(transform)\n\nTells whether or not the transform is revertible, i.e. supports a revert function. Defaults to false for new transform types.\n\nTransforms can be revertible and yet don't be invertible. Invertibility is a mathematical concept, whereas revertibility is a computational concept.\n\nSee also isinvertible.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"To exemplify the use of these functions, let's create a table:","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = [-1.0, 4.0, 1.6, 3.4]\nb = [1.6, 3.4, -1.0, 4.0]\nc = [3.4, 2.0, 3.6, -1.0]\ntable = (; a, b, c)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, let's choose a transform and check that it is revertible:","category":"page"},{"location":"","page":"Home","title":"Home","text":"transform = Center()\nisrevertible(transform)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We apply the transformation to the table and save the cache in a variable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"newtable, cache = apply(transform, table)\nnewtable","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using the cache we can revert the transform:","category":"page"},{"location":"","page":"Home","title":"Home","text":"original = revert(transform, newtable, cache)","category":"page"},{"location":"#Reapplying-transforms","page":"Home","title":"Reapplying transforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Finally, it is sometimes useful to reapply a transform that was \"fitted\" with training data to unseen test data. In this case, the cache from a previous apply call is used:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reapply","category":"page"},{"location":"#TransformsBase.reapply","page":"Home","title":"TransformsBase.reapply","text":"newobject = reapply(transform, object, cache)\n\nReapply the transform to (a possibly different) object using a cache that was created with a previous apply call. Fallback to apply without using the cache.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Consider the following example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"traintable = (a = rand(3), b = rand(3), c = rand(3))\ntesttable  = (a = rand(3), b = rand(3), c = rand(3))\n\ntransform = ZScore()\n\n# ZScore transform \"fits\" μ and σ using training data\nnewtable, cache = apply(transform, traintable)\n\n# we can reuse the same values of μ and σ with test data\nnewtable = reapply(transform, testtable, cache)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this result is different from the result returned by the apply function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"newtable, cache = apply(transform, testtable)\nnewtable","category":"page"}]
}
