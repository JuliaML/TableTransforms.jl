# ------------------------------------------------------------------
# Licensed under the MIT License. See LICENSE in the project root.
# ------------------------------------------------------------------

"""
    Map(fun₁ => target₁, fun₂, ..., funₙ => targetₙ)

Applies the `funᵢ` function to each row using 
and saves the result in a new column named `targetᵢ`.

Passing a target column name is optional and when omitted a new name
is generated by joining the function name.
If the target column already exists in the table, the original
column will be replaced.

# Examples

```julia
Map(row->sin(row.a))
Map((row->sum(row)) => :col1)
Map((row->row.a^2) => :col1, (row->row.b + row.c) => :col2)
```

## Notes

* Anonymous functions must be passed with parentheses as in the examples above;
* Some function names are treated in a special way, they are:
  * Anonymous functions: `#1` -> `f1`;
  * Composed functions: `outer ∘ inner` -> `outer_inner`;
  * `Base.Fix1` functions: `Base.Fix1(f, x)` -> `fix1_f`;
  * `Base.Fix2` functions: `Base.Fix2(f, x)` -> `fix2_f`;
"""
struct Map <: StatelessFeatureTransform
  funs::Vector{Function}
  targets::Vector{Union{Nothing,Symbol}}
end

Map() = throw(ArgumentError("cannot create Map transform without arguments"))

# utility types
const TargetName = Union{Symbol,AbstractString}
const PairFunctionTarget = Pair{<:Function,<:TargetName}
const MapPair = Union{PairFunctionTarget,Function}

# utility functions
_extract(p::PairFunctionTarget) = first(p), Symbol(last(p))
_extract(p::Function) = p, nothing

function Map(pairs::MapPair...)
  tuples = map(_extract, pairs)
  funs = [t[1] for t in tuples]
  targets = [t[2] for t in tuples]
  Map(funs, targets)
end

isrevertible(::Type{Map}) = false

# _funname(fun::Base.Fix1) = "fix1_" * _funname(fun.f)
# _funname(fun::Base.Fix2) = "fix2_" * _funname(fun.f)
# _funname(fun::ComposedFunction) = _funname(fun.outer) * "_" * _funname(fun.inner)
_funname(fun) = string(fun)

function applyfeat(transform::Map, feat, prep)
  rows = Tables.rows(feat)
  funs = transform.funs
  targets = transform.targets
  mapped = map(funs, targets) do fun, target
    newname = isnothing(target) ? Symbol(_funname(fun)) : target
    newcolumn = map(row->fun(Tables.Row(row)),rows)
    newname => newcolumn
  end
  newfeat = merge(Tables.columns(feat),mapped) |> Tables.materializer(feat)
  newfeat, nothing
end