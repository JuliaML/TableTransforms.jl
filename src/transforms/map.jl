# ------------------------------------------------------------------
# Licensed under the MIT License. See LICENSE in the project root.
# ------------------------------------------------------------------

# supported argument types
const Callable = Union{Function,Type}
const Target = Union{Symbol,AbstractString}
const ColsCallableTarget = Pair{<:Any,<:Pair{<:Callable,<:Target}}
const ColsCallable = Pair{<:Any,<:Callable}
const CallableTarget = Pair{<:Callable,<:Target}
const MapArg = Union{ColsCallableTarget,ColsCallable,CallableTarget,Callable}

"""
    Map(cols₁ => fun₁ => target₁, cols₂ => fun₂, ..., colsₙ => funₙ => targetₙ)

Applies the `funᵢ` function to the columns selected by `colsᵢ` using 
the `map` function and saves the result in a new column named `targetᵢ`.
Types are also allowed in place of functions to construct objects with
arguments from the columns.

The column selection can be a single column identifier (index or name),
a collection of identifiers or a regular expression (regex). It can also
be ommited to apply the function to all columns.

Passing a target column name is optional and when omitted a new name
is generated by joining the function name with the selected column names.

## Examples

```julia
Map(1 => sin)
Map(:a => sin, "b" => cos => :cos_b)
Map([2, 3] => ((b, c) -> 2b + c))
Map([:a, :c] => ((a, c) -> 2a * 3c) => :col1)
Map(["c", "a"] => ((c, a) -> 3c / a) => :col1, "c" => tan)
Map(r"[abc]" => ((a, b, c) -> a^2 - 2b + c) => "col1")
Map(sin => "seno")
Map(cos)
```

## Notes

* Anonymous functions must be passed with parentheses as in the examples above

* Some function names are treated in a special way, they are:
  * Anonymous functions: `#1` -> `f1`;
  * Composed functions: `outer ∘ inner` -> `outer_inner`;
  * `Base.Fix1` functions: `Base.Fix1(f, x)` -> `fix1_f`;
  * `Base.Fix2` functions: `Base.Fix2(f, x)` -> `fix2_f`;
"""
struct Map <: StatelessFeatureTransform
  selectors::Vector{ColumnSelector}
  funs::Vector{Callable}
  targets::Vector{Union{Nothing,Symbol}}
end

function Map(args::MapArg...)
  tups = map(_extract, args)
  sels = [t[1] for t in tups]
  funs = [t[2] for t in tups]
  tars = [t[3] for t in tups]
  Map(sels, funs, tars)
end

Map() = throw(ArgumentError("cannot create Map transform without arguments"))

function applyfeat(transform::Map, feat, prep)
  cols = Tables.columns(feat)
  names = Tables.columnnames(cols)

  selectors = transform.selectors
  funs = transform.funs
  targets = transform.targets

  mapped = map(selectors, funs, targets) do selector, fun, target
    snames = selector(names)
    newname = isnothing(target) ? _makename(snames, fun) : target
    scolumns = (Tables.getcolumn(cols, nm) for nm in snames)
    newcolumn = map(fun, scolumns...)
    newname => newcolumn
  end

  newfeat = (; mapped...) |> Tables.materializer(feat)

  newfeat, nothing
end

_extract(arg::ColsCallableTarget) = selector(first(arg)), first(last(arg)), Symbol(last(last(arg)))
_extract(arg::ColsCallable) = selector(first(arg)), last(arg), nothing
_extract(arg::CallableTarget) = AllSelector(), first(arg), Symbol(last(arg))
_extract(arg::Callable) = AllSelector(), arg, nothing

function _makename(snames, fun)
  funname = _funname(fun)
  if contains(funname, "#") # anonymous functions
    funname = replace(funname, "#" => "f")
  end
  Symbol(funname, :_, join(snames, "_"))
end

_funname(fun::Base.Fix1) = "fix1_" * _funname(fun.f)
_funname(fun::Base.Fix2) = "fix2_" * _funname(fun.f)
_funname(fun::ComposedFunction) = _funname(fun.outer) * "_" * _funname(fun.inner)
_funname(fun) = string(fun)
