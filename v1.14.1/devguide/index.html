<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer guide · TableTransforms.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaML.github.io/TableTransforms.jl/devguide/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="TableTransforms.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TableTransforms.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../transforms/">Transforms</a></li><li class="is-active"><a class="tocitem" href>Developer guide</a><ul class="internal"><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Basic-assumptions"><span>Basic assumptions</span></a></li><li><a class="tocitem" href="#Defining-a-new-transform"><span>Defining a new transform</span></a></li></ul></li><li><a class="tocitem" href="../related/">Related</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaML/TableTransforms.jl/blob/master/docs/src/devguide.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-guide"><a class="docs-heading-anchor" href="#Developer-guide">Developer guide</a><a id="Developer-guide-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-guide" title="Permalink"></a></h1><p>A short guide for extending the interface as a developer.</p><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>TableTransforms.jl currently supports over 25 different transforms that cover a wide variety of use cases ranging from ordinary table operations to complex statistical transformations, which can be arbitrarily composed with one another through elegant syntax. It is easy to leverage all this functionality as a developer of new transforms, and this is the motivation of this guide.</p><h2 id="Basic-assumptions"><a class="docs-heading-anchor" href="#Basic-assumptions">Basic assumptions</a><a id="Basic-assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-assumptions" title="Permalink"></a></h2><p>All the transforms in this package implement the transforms interface defined in the  TransformsBase.jl package so this is really the only dependency needed. The interface assumes the following about new transforms:</p><ul><li>Transforms operate on a single table</li><li>Transforms may be associated with some state that if computed while applying it for the first time and is then cached can help later reapply the transform on another table without recomputing the state</li><li>The transform may be revertible, meaning that a transformed table can be brought back to its original form, and it may need to use the cache for that</li><li>Your transform may be invertible in the mathematical sense</li></ul><div class="admonition is-info"><header class="admonition-header">Revertible does not imply invertible</header><div class="admonition-body"><p>Reversibility assumes that the transform has been applied already and can be undone. On the other hand, invertibility implies that there is a one-to-one mapping between the input and output tables so a table can be inverted to a corresponding input even if it was not transformed a priori.</p></div></div><h2 id="Defining-a-new-transform"><a class="docs-heading-anchor" href="#Defining-a-new-transform">Defining a new transform</a><a id="Defining-a-new-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-new-transform" title="Permalink"></a></h2><p>In the following we shall demonstrate the steps to define a new transform.</p><h3 id=".-Declare-a-new-type-for-your-transform"><a class="docs-heading-anchor" href="#.-Declare-a-new-type-for-your-transform">1. Declare a new type for your transform</a><a id=".-Declare-a-new-type-for-your-transform-1"></a><a class="docs-heading-anchor-permalink" href="#.-Declare-a-new-type-for-your-transform" title="Permalink"></a></h3><p>The type should subtype <code>TransformsBase.Transform</code> and it should have a named field for each  parameter needed to apply the transform besides the input table. For instance, if you want to call  your transform <code>Standardize</code> and it takes two boolean inputs <code>center</code> and <code>scale</code> , then you should declare:</p><pre><code class="language-julia hljs">struct Standardize &lt;: TransformsBase.Transform
  center::Bool
  scale::Bool
end</code></pre><p>You may implement keyword constructors as needed if some of the parameters are optional:</p><pre><code class="language-julia hljs">Standardize(; center::Bool=true, scale::Bool=true) = Standardize(center, scale)</code></pre><h3 id=".-Implement-the-apply-method-for-your-transform"><a class="docs-heading-anchor" href="#.-Implement-the-apply-method-for-your-transform">2. Implement the <code>apply</code> method for your transform</a><a id=".-Implement-the-apply-method-for-your-transform-1"></a><a class="docs-heading-anchor-permalink" href="#.-Implement-the-apply-method-for-your-transform" title="Permalink"></a></h3><p>The <code>apply</code> method takes an instance of your transform type and a table and returns a new table  and cache. Suppose that the <code>Standardize</code> transform should zero-mean each column if <code>center</code> is  true and scale each column to unit variance if <code>scale</code> is true, then the <code>apply</code> method should  be implemented as follows:</p><pre><code class="language-julia hljs">using Statistics

function TransformsBase.apply(transform::Standardize, X)
    # convert the table to a matrix
    Xm = Tables.matrix(X)
    # compute the means and stds
    μ = transform.center ? mean(Xm, dims=1) : zeros(1, size(Xm, 2))
    σ = transform.scale ? std(Xm, dims=1) : ones(1, size(Xm, 2))
    # standardize the data
    Xm = (Xm .- μ) ./ σ
    # convert back to table
    Xm = X |&gt; Tables.materializer(Xm)
    # return the table and cache that may help reapply or revert later
    return Xm, (μ, σ)
end</code></pre><p>That&#39;s it really! Your transform now behaves like any table transform:</p><pre><code class="language-julia hljs">using TableTransforms

X = (A=[1, 2, 3], B=[4, 5, 6])
Xt = X |&gt; Standardize() |&gt; Identity() |&gt; Select([:A])</code></pre><p>It holds, however, that in case your transform can be reapplied, is revertible, or is  invertible then you should continue implementing the interface to support such functionality.</p><h3 id=".-Optionally-implement-reapply"><a class="docs-heading-anchor" href="#.-Optionally-implement-reapply">3. Optionally implement <code>reapply</code></a><a id=".-Optionally-implement-reapply-1"></a><a class="docs-heading-anchor-permalink" href="#.-Optionally-implement-reapply" title="Permalink"></a></h3><p>We need this in case of the <code>Standarize</code> transform because after computing the mean and std for  some training table we may want to apply the transform directly given a test table. Hence, we implement <code>reapply</code> which has the same signature as apply but it takes an extra argument for the cache and doesn&#39;t return it.</p><pre><code class="language-julia hljs">function TransformsBase.reapply(transform::Standardize, X, cache)
    # convert the table to a matrix
    Xm = Tables.matrix(X)
    # no need to recompute means and stds
    μ, σ = cache
    # standardize the data
    Xm = (Xm .- μ) ./ σ
    # convert back to table
    Xm = X |&gt; Tables.materializer(Xm)
    return Xm
end</code></pre><p>If not implemented, <code>reapply</code> simply falls back to <code>apply</code>.</p><h3 id=".-Optionally-specify-that-your-transform-is-revertible-and-implement-revert"><a class="docs-heading-anchor" href="#.-Optionally-specify-that-your-transform-is-revertible-and-implement-revert">4. Optionally specify that your transform is revertible and implement <code>revert</code></a><a id=".-Optionally-specify-that-your-transform-is-revertible-and-implement-revert-1"></a><a class="docs-heading-anchor-permalink" href="#.-Optionally-specify-that-your-transform-is-revertible-and-implement-revert" title="Permalink"></a></h3><p>We can specify reversibility for an arbitrary transform <code>T</code> by setting <code>isrevertible(::Type{T})</code> to <code>true</code>. It&#39;s obvious that this should be supported by our transform  so we do</p><pre><code class="language-julia hljs">TransformsBase.isrevertible(::Type{Standardize}) = true</code></pre><p>By default this falls back to <code>false</code> so users of the interface would be aware that revert is not  implemented in that case. Now we follow up by implementing the <code>revert</code> method:</p><pre><code class="language-julia hljs">function TransformsBase.revert(transform::Standardize, X, cache)
    # convert the table to a matrix
    Xm = Tables.matrix(X)
    # extract the mean and std
    μ, σ = cache
    # revert the transform
    Xm = Xm .* σ .+ μ
    # convert back to table
    Xm = X |&gt; Tables.materializer(Xm)
    return Xm
end</code></pre><h3 id=".-Optionally-specify-that-your-transform-is-invertible-and-implement-Base.inv"><a class="docs-heading-anchor" href="#.-Optionally-specify-that-your-transform-is-invertible-and-implement-Base.inv">5. Optionally specify that your transform is invertible and implement <code>Base.inv</code></a><a id=".-Optionally-specify-that-your-transform-is-invertible-and-implement-Base.inv-1"></a><a class="docs-heading-anchor-permalink" href="#.-Optionally-specify-that-your-transform-is-invertible-and-implement-Base.inv" title="Permalink"></a></h3><p>Similar to reversibility, falls back to <code>false</code> by default. We can write that explicitly here  since <code>Standardize</code> has no inverse if we are given nothing except for the table.</p><pre><code class="language-julia hljs">TransformsBase.isinvertible(::Type{Standardize}) = false</code></pre><p>If an arbitrary transform <code>T</code> is invertible we can rather specify that as <code>true</code> and follow up by  implementing <code>Base.inv(::T)</code> which would be expected to return an instance of the inverse  transform. For instance, for an identity transform we can do</p><pre><code class="language-julia hljs"># interface struct
struct Identity &lt;: Transform end
# specify that it is invertible
TransformsBase.isinvertible(::Type{Identity}) = true
# implement Base.inv
Base.inv(::Identity) = Identity()</code></pre><p>which implies that <code>inv(Identity())</code> would return an identity transform.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transforms/">« Transforms</a><a class="docs-footer-nextpage" href="../related/">Related »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 31 August 2023 12:01">Thursday 31 August 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
